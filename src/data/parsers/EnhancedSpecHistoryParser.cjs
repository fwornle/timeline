/**
 * CommonJS wrapper for EnhancedSpecHistoryParser
 * Direct implementation in CommonJS for the Node.js server
 */

/**
 * Parse a spec history file to extract individual prompts
 */
function parseSpecFileToPrompts(filename, content) {
  const fileDate = extractDateFromFilename(filename);
  const prompts = [];
  
  // Split content into lines
  const lines = content.split('\n');
  
  // Detect file format
  const isClaudeCodeFormat = content.includes('# Auto-logged Claude Code Session') || content.includes('## User') || content.includes('## Assistant');
  const isSpecStoryFormat = content.includes('<!-- Generated by SpecStory -->') || content.includes('_**User**_');
  
  if (isClaudeCodeFormat) {
    return parseClaudeCodeFormat(filename, content, fileDate, lines);
  } else if (isSpecStoryFormat) {
    return parseSpecStoryFormat(filename, content, fileDate, lines);
  } else {
    // Fallback: try to detect user prompts with various patterns
    return parseGenericFormat(filename, content, fileDate, lines);
  }
}

/**
 * Parse Claude Code auto-logged session format
 */
function parseClaudeCodeFormat(filename, content, fileDate, lines) {
  const prompts = [];
  
  // content parameter is not directly used here as we work with lines array
  
  // Find all user prompts (lines starting with "## User")
  const promptIndices = [];
  lines.forEach((line, index) => {
    if (line.trim() === '## User') {
      promptIndices.push(index);
    }
  });

  // Process each prompt and its response
  for (let i = 0; i < promptIndices.length; i++) {
    const promptStartIndex = promptIndices[i];
    const promptEndIndex = i < promptIndices.length - 1 ? promptIndices[i + 1] : lines.length;
    
    // Find assistant response start
    const promptSection = lines.slice(promptStartIndex, promptEndIndex);
    const assistantIndex = promptSection.findIndex(line => line.trim() === '## Assistant');
    
    if (assistantIndex !== -1) {
      // Extract timestamp for user prompt (line after "## User")
      const userTimestamp = extractTimestampFromLine(promptSection[1]);
      
      // Extract prompt text (between timestamp and "## Assistant")
      const promptText = promptSection.slice(2, assistantIndex)
        .filter(line => line.trim() !== '' && line.trim() !== '---')
        .join('\n')
        .trim();
      
      // Extract assistant timestamp (line after "## Assistant")
      const assistantTimestamp = extractTimestampFromLine(promptSection[assistantIndex + 1]);
      
      // Extract response text
      const responseText = promptSection.slice(assistantIndex + 2)
        .filter(line => line.trim() !== '---')
        .join('\n')
        .trim();
      
      // Parse stats for this specific prompt
      const stats = parsePromptStats(promptSection.slice(assistantIndex));
      
      prompts.push({
        promptText,
        responseText,
        index: i,
        userTimestamp,
        assistantTimestamp,
        hasDetailedTiming: true,
        ...stats
      });
    }
  }

  return buildSpecFileResult(filename, fileDate, prompts);
}

/**
 * Parse SpecStory format (legacy)
 */
function parseSpecStoryFormat(filename, content, fileDate, lines) {
  const prompts = [];
  
  // content parameter is not directly used here as we work with lines array
  
  // Find all prompts (lines starting with _**User**_)
  const promptIndices = [];
  lines.forEach((line, index) => {
    if (line.trim().startsWith('_**User**_')) {
      promptIndices.push(index);
    }
  });

  // Process each prompt and its response
  for (let i = 0; i < promptIndices.length; i++) {
    const promptStartIndex = promptIndices[i];
    const promptEndIndex = i < promptIndices.length - 1 ? promptIndices[i + 1] : lines.length;
    
    // Find assistant response start
    const promptSection = lines.slice(promptStartIndex, promptEndIndex);
    const assistantIndex = promptSection.findIndex(line => line.trim().startsWith('_**Assistant**_'));
    
    if (assistantIndex !== -1) {
      // Extract prompt text (between _**User**_ and _**Assistant**_)
      const promptText = promptSection.slice(1, assistantIndex)
        .filter(line => line.trim() !== '' && line.trim() !== '---')
        .join('\n')
        .trim();
      
      // Extract response text
      const responseText = promptSection.slice(assistantIndex + 1)
        .filter(line => line.trim() !== '---')
        .join('\n')
        .trim();
      
      // Parse stats for this specific prompt
      const stats = parsePromptStats(promptSection.slice(assistantIndex));
      
      prompts.push({
        promptText,
        responseText,
        index: i,
        hasDetailedTiming: false,
        ...stats
      });
    }
  }

  return buildSpecFileResult(filename, fileDate, prompts);
}

/**
 * Parse generic format (fallback)
 */
function parseGenericFormat(filename, content, fileDate, lines) {
  const prompts = [];
  
  // Try to find various user prompt patterns
  const promptPatterns = [
    /^\s*user:/i,
    /^\s*prompt:/i,
    /^\s*q:/i,
    /^\s*question:/i,
    /^\s*\*\*user\*\*/i,
    /^\s*## user/i
  ];
  
  const promptIndices = [];
  lines.forEach((line, index) => {
    if (promptPatterns.some(pattern => pattern.test(line))) {
      promptIndices.push(index);
    }
  });

  // If no patterns found, treat the entire content as one prompt
  if (promptIndices.length === 0) {
    const stats = parsePromptStats(lines);
    prompts.push({
      promptText: content.substring(0, Math.min(200, content.length)) + '...',
      responseText: content,
      index: 0,
      hasDetailedTiming: false,
      ...stats
    });
  } else {
    // Process found prompts
    for (let i = 0; i < promptIndices.length; i++) {
      const promptStartIndex = promptIndices[i];
      const promptEndIndex = i < promptIndices.length - 1 ? promptIndices[i + 1] : lines.length;
      
      const promptSection = lines.slice(promptStartIndex, promptEndIndex);
      const promptText = promptSection.slice(0, Math.min(5, promptSection.length))
        .join('\n')
        .trim();
      
      const responseText = promptSection.slice(1)
        .join('\n')
        .trim();
      
      const stats = parsePromptStats(promptSection);
      
      prompts.push({
        promptText,
        responseText,
        index: i,
        hasDetailedTiming: false,
        ...stats
      });
    }
  }

  return buildSpecFileResult(filename, fileDate, prompts);
}

/**
 * Build the final spec file result with calculated stats
 */
function buildSpecFileResult(filename, fileDate, prompts) {
  // Calculate total stats
  const totalStats = {
    promptCount: prompts.length,
    filesCreated: prompts.reduce((sum, p) => sum + p.filesCreated, 0),
    filesModified: prompts.reduce((sum, p) => sum + p.filesModified, 0),
    linesAdded: prompts.reduce((sum, p) => sum + p.linesAdded, 0),
    linesDeleted: prompts.reduce((sum, p) => sum + p.linesDeleted, 0),
    linesDelta: prompts.reduce((sum, p) => sum + p.linesDelta, 0),
    toolInvocations: prompts.reduce((sum, p) => sum + p.toolInvocations, 0)
  };

  return {
    filename,
    fileDate,
    prompts,
    totalStats,
    hasDetailedTiming: prompts.some(p => p.hasDetailedTiming)
  };
}

/**
 * Parse stats for a single prompt's assistant response
 */
function parsePromptStats(responseLines) {
  const stats = {
    filesCreated: 0,
    filesModified: 0,
    linesAdded: 0,
    linesDeleted: 0,
    linesDelta: 0,
    toolInvocations: 0
  };

  let inCodeBlock = false;
  let codeBlockType = '';
  let isFileDiff = false;

  for (let i = 0; i < responseLines.length; i++) {
    const line = responseLines[i].trim();

    // Check for code block start
    if (line.startsWith('```') && !inCodeBlock) {
      inCodeBlock = true;
      codeBlockType = line.substring(3).trim();
      
      // Determine block type
      const isFileCreation = codeBlockType !== 'diff' && codeBlockType !== 'bash' && 
                           codeBlockType !== 'shell' && codeBlockType !== '';
      isFileDiff = codeBlockType === 'diff';
      const isToolInvocation = codeBlockType === 'bash' || codeBlockType === 'shell';
      
      if (isFileCreation) {
        stats.filesCreated++;
      } else if (isToolInvocation) {
        stats.toolInvocations++;
      }
      
      continue;
    }

    // Check for code block end
    if (line === '```' && inCodeBlock) {
      inCodeBlock = false;
      isFileDiff = false;
      continue;
    }

    // Count lines in diff blocks
    if (inCodeBlock && isFileDiff) {
      if (line.startsWith('+') && !line.startsWith('+++')) {
        stats.linesAdded++;
      } else if (line.startsWith('-') && !line.startsWith('---')) {
        stats.linesDeleted++;
      }
    }
  }

  // Count modified files (each diff block represents one modified file)
  let diffBlockCount = 0;
  let inDiff = false;
  
  for (let i = 0; i < responseLines.length; i++) {
    const line = responseLines[i].trim();
    
    if (line === '```diff' && !inDiff) {
      inDiff = true;
      diffBlockCount++;
    } else if (line === '```' && inDiff) {
      inDiff = false;
    }
  }
  
  stats.filesModified = diffBlockCount;
  stats.linesDelta = stats.linesAdded - stats.linesDeleted;

  return stats;
}

/**
 * Extract timestamp from a line (for Claude Code format)
 */
function extractTimestampFromLine(line) {
  if (!line) return null;
  
  // Look for timestamp pattern: *2025-06-11T05:31:00.654Z*
  const timestampMatch = line.match(/\*(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}\.\d{3}Z)\*/);
  if (timestampMatch) {
    return new Date(timestampMatch[1]);
  }
  
  // Look for other ISO timestamp patterns
  const isoMatch = line.match(/(\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(?:\.\d{3})?Z?)/);
  if (isoMatch) {
    return new Date(isoMatch[1]);
  }
  
  return null;
}

/**
 * Extract date from specstory filename
 */
function extractDateFromFilename(filename) {
  // Expected format: YYYY-MM-DD-HH-MM-SS-title.md or YYYY-MM-DD_HH-MM-title.md
  let match = filename.match(/^(\d{4})-(\d{2})-(\d{2})[-_](\d{2})-(\d{2})-(\d{2})/);
  if (match) {
    const [, year, month, day, hour, minute, second] = match;
    return new Date(
      parseInt(year),
      parseInt(month) - 1,
      parseInt(day),
      parseInt(hour),
      parseInt(minute),
      parseInt(second)
    );
  }
  
  // Try without seconds: YYYY-MM-DD_HH-MM-title.md
  match = filename.match(/^(\d{4})-(\d{2})-(\d{2})[-_](\d{2})-(\d{2})/);
  if (match) {
    const [, year, month, day, hour, minute] = match;
    return new Date(
      parseInt(year),
      parseInt(month) - 1,
      parseInt(day),
      parseInt(hour),
      parseInt(minute),
      0
    );
  }
  
  // Fallback to date-only format: YYYY-MM-DD-title.md
  const dateMatch = filename.match(/^(\d{4})-(\d{2})-(\d{2})/);
  if (dateMatch) {
    const [, year, month, day] = dateMatch;
    return new Date(parseInt(year), parseInt(month) - 1, parseInt(day));
  }
  
  // If no date found, return current date
  return new Date();
}

/**
 * Correlate spec files with git commits to estimate prompt timings
 */
function correlateSpecFilesWithCommits(specFiles, gitCommits) {
  // Sort spec files and commits by date
  const sortedSpecs = [...specFiles].sort((a, b) => a.fileDate.getTime() - b.fileDate.getTime());
  const sortedCommits = [...gitCommits].sort((a, b) => a.timestamp.getTime() - b.timestamp.getTime());
  
  const bundles = [];
  
  for (let i = 0; i < sortedSpecs.length; i++) {
    const specFile = sortedSpecs[i];
    const nextSpecFile = sortedSpecs[i + 1];
    
    // Find commits that belong to this spec file
    // (after this spec file date and before next spec file date)
    const specCommits = sortedCommits.filter(commit => {
      const afterThisSpec = commit.timestamp.getTime() >= specFile.fileDate.getTime();
      const beforeNextSpec = !nextSpecFile || commit.timestamp.getTime() < nextSpecFile.fileDate.getTime();
      return afterThisSpec && beforeNextSpec;
    });
    
    const firstCommit = specCommits.length > 0 ? specCommits[0] : null;
    const lastCommit = specCommits.length > 0 ? specCommits[specCommits.length - 1] : null;
    
    // Calculate estimated prompt duration
    let estimatedPromptDuration = 0;
    if (firstCommit && lastCommit && specFile.prompts.length > 0) {
      const totalDuration = lastCommit.timestamp.getTime() - firstCommit.timestamp.getTime();
      estimatedPromptDuration = totalDuration / specFile.prompts.length;
    }
    
    bundles.push({
      specFile,
      commits: specCommits,
      firstCommit,
      lastCommit,
      estimatedPromptDuration
    });
  }
  
  return bundles;
}

/**
 * Calculate consistent prompt duration across spec files
 */
function calculateConsistentPromptDuration(bundles) {
  // Filter out bundles with unreliable estimates
  const reliableBundles = bundles.filter(bundle => 
    bundle.estimatedPromptDuration > 0 &&
    bundle.estimatedPromptDuration < 24 * 60 * 60 * 1000 && // Less than 24 hours
    bundle.commits.length > 0 &&
    bundle.specFile.prompts.length > 0
  );
  
  if (reliableBundles.length === 0) {
    // Default to 30 minutes per prompt
    return 30 * 60 * 1000;
  }
  
  // Calculate median duration (more robust than average)
  const durations = reliableBundles.map(b => b.estimatedPromptDuration).sort((a, b) => a - b);
  const midIndex = Math.floor(durations.length / 2);
  
  if (durations.length % 2 === 0) {
    return (durations[midIndex - 1] + durations[midIndex]) / 2;
  } else {
    return durations[midIndex];
  }
}

/**
 * Assign timestamps to individual prompts based on estimated durations
 */
function assignPromptTimestamps(bundles, consistentDuration) {
  return bundles.map(bundle => {
    const { specFile, firstCommit } = bundle;
    
    // For files with detailed timing, use actual timestamps
    if (specFile.hasDetailedTiming) {
      const promptsWithTimestamps = specFile.prompts.map((prompt, index) => {
        let estimatedTimestamp;
        
        if (prompt.userTimestamp) {
          // Use actual user timestamp from Claude Code format
          estimatedTimestamp = prompt.userTimestamp;
        } else if (prompt.assistantTimestamp) {
          // Use assistant timestamp if user timestamp not available
          estimatedTimestamp = prompt.assistantTimestamp;
        } else {
          // Fallback to estimated timing
          const startTime = firstCommit 
            ? firstCommit.timestamp.getTime()
            : specFile.fileDate.getTime();
          estimatedTimestamp = new Date(startTime + (index * consistentDuration));
        }
        
        return {
          ...prompt,
          estimatedTimestamp
        };
      });
      
      return {
        ...bundle,
        specFile: {
          ...specFile,
          prompts: promptsWithTimestamps
        }
      };
    } else {
      // Use estimated timing for files without detailed timestamps
      const startTime = firstCommit 
        ? firstCommit.timestamp.getTime()
        : specFile.fileDate.getTime();
      
      // Assign timestamps to each prompt
      const promptsWithTimestamps = specFile.prompts.map((prompt, index) => ({
        ...prompt,
        estimatedTimestamp: new Date(startTime + (index * consistentDuration))
      }));
      
      return {
        ...bundle,
        specFile: {
          ...specFile,
          prompts: promptsWithTimestamps
        }
      };
    }
  });
}

// Export the functions
module.exports = {
  parseSpecFileToPrompts,
  correlateSpecFilesWithCommits,
  calculateConsistentPromptDuration,
  assignPromptTimestamps
};